<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.506">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Nicholas Shuckerow">
<meta name="dcterms.date" content="2024-06-18">

<title>Nick_Shuckerow - Forecasting Methods</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script><script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<script src="../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>

<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../../index.html">
    <span class="navbar-title">Nick_Shuckerow</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../index.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../resume.html"> 
<span class="menu-text">Resume</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../projects.html"> 
<span class="menu-text">Projects</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#forecasting-methods" id="toc-forecasting-methods" class="nav-link active" data-scroll-target="#forecasting-methods">Forecasting Methods</a>
  <ul class="collapse">
  <li><a href="#average" id="toc-average" class="nav-link" data-scroll-target="#average">Average</a></li>
  <li><a href="#simple-exponential-smoothing" id="toc-simple-exponential-smoothing" class="nav-link" data-scroll-target="#simple-exponential-smoothing">Simple Exponential Smoothing</a></li>
  <li><a href="#holts-linear-trend-method" id="toc-holts-linear-trend-method" class="nav-link" data-scroll-target="#holts-linear-trend-method">Holt’s Linear Trend Method</a></li>
  </ul></li>
  <li><a href="#evaluation" id="toc-evaluation" class="nav-link" data-scroll-target="#evaluation">Evaluation</a>
  <ul class="collapse">
  <li><a href="#initial-setup" id="toc-initial-setup" class="nav-link" data-scroll-target="#initial-setup">Initial Setup</a></li>
  <li><a href="#average-1" id="toc-average-1" class="nav-link" data-scroll-target="#average-1">Average</a>
  <ul class="collapse">
  <li><a href="#cumulative-average" id="toc-cumulative-average" class="nav-link" data-scroll-target="#cumulative-average">Cumulative Average</a></li>
  </ul></li>
  <li><a href="#simple-exponential-smoothing-1" id="toc-simple-exponential-smoothing-1" class="nav-link" data-scroll-target="#simple-exponential-smoothing-1">Simple Exponential Smoothing</a>
  <ul class="collapse">
  <li><a href="#ses-optimized" id="toc-ses-optimized" class="nav-link" data-scroll-target="#ses-optimized">SES Optimized</a></li>
  </ul></li>
  <li><a href="#holts-linear-trend-method-1" id="toc-holts-linear-trend-method-1" class="nav-link" data-scroll-target="#holts-linear-trend-method-1">Holt’s Linear Trend Method</a>
  <ul class="collapse">
  <li><a href="#optimized-holts" id="toc-optimized-holts" class="nav-link" data-scroll-target="#optimized-holts">Optimized Holts</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion">Conclusion</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Forecasting Methods</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Nicholas Shuckerow </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">June 18, 2024</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="forecasting-methods" class="level1">
<h1>Forecasting Methods</h1>
<p>Forecasting plays a critical role in a plethora of industries. It allows businesses to plan for the future, anticipate demand, and make informed decisions. In this notebook, we will explore some of the most popular forecasting methods and apply them to the problem of predicting the future sales of a retail store.</p>
<p>We’ll be going over averages, simple exponential smoothing, and Holt’s linear trend method.</p>
<section id="average" class="level2">
<h2 class="anchored" data-anchor-id="average">Average</h2>
<p>The natural tendency when trying to forecast a time series is to use the average of the series. This is a simple method that can be useful when the series is relatively stable and doesn’t have any trends or seasonality. However, this is the simplest of methods, and may not be maximizing your profits.</p>
</section>
<section id="simple-exponential-smoothing" class="level2">
<h2 class="anchored" data-anchor-id="simple-exponential-smoothing">Simple Exponential Smoothing</h2>
<p>Simple exponential smoothing (SES) is a technique that assigns a weight to past observations in order to make the next prediction. The weight can be between 0 and 1, with 1 meaning that it takes the full value of the previous observation and 0 meaning that it ignores the previous observation completely.</p>
<p>The formula for Simple Exponential Smoothing is:</p>
<p><span class="math display">\[ F_{t+1} = \alpha Y_t + (1 - \alpha) F_t \]</span></p>
<p>Where:</p>
<ul>
<li><span class="math inline">\(F_{t+1}\)</span> is the forecast for the next period</li>
<li><span class="math inline">\(Y_t\)</span> is the actual value for the current period</li>
<li><span class="math inline">\(F_t\)</span> is the forecast for the current period</li>
<li><span class="math inline">\(\alpha\)</span> is the smoothing factor or level</li>
</ul>
<p>We’ll see alpha be called the smoothing level in python packages for SES.</p>
<p>A loss function can also be incorporated into the SES model in order to optimize your parameters. A loss function is a method of evaluating how well your algorithm and its parameters are performing. The most common loss function for SES is the Mean Squared Error (MSE). The MSE is calculated by taking the difference between the actual value and the forecasted value, squaring it, and then taking the average of all the squared differences.</p>
<p>Once the loss function is calculated, the goal is to minimize the loss by adjusting the parameters which in this case is the smoothing factor. There are many optimization algorithms that can be used to minimize the loss function, such as gradient descent.</p>
</section>
<section id="holts-linear-trend-method" class="level2">
<h2 class="anchored" data-anchor-id="holts-linear-trend-method">Holt’s Linear Trend Method</h2>
<p>Holt’s Linear Trend Method is an extension of SES that incorporates a trend component. This method is useful when the data has a trend but no seasonality. The formula for Holt’s Linear Trend Method is:</p>
<p><span class="math display">\[ F_{t+h} = l_t + h \cdot b_t \]</span></p>
<p>Where:</p>
<ul>
<li><span class="math inline">\(F_{t+h}\)</span> is the forecast for the next period</li>
<li><span class="math inline">\(l_t\)</span> is the smoothed value at the current period</li>
<li><span class="math inline">\(b_t\)</span> is the trend for the current period</li>
<li><span class="math inline">\(h\)</span> is the number of periods into the future you want to forecast</li>
</ul>
<p>The formula for the level, <span class="math inline">\(l_t\)</span>, is:</p>
<p><span class="math display">\[ l_t = \alpha Y_t + (1 - \alpha)(l_{t-1} + b_{t-1}) \]</span></p>
<p>The formula for the trend, <span class="math inline">\(b_t\)</span>, is:</p>
<p><span class="math display">\[ b_t = \beta(l_t - l_{t-1}) + (1 - \beta)b_{t-1} \]</span></p>
<p>Where:</p>
<ul>
<li><span class="math inline">\(\alpha\)</span> is the smoothing factor for the level</li>
<li><span class="math inline">\(\beta\)</span> is the smoothing factor for the trend</li>
<li><span class="math inline">\(Y_t\)</span> is the actual value for the current period</li>
<li><span class="math inline">\(l_{t-1}\)</span> is the smoothed value for the previous period</li>
<li><span class="math inline">\(b_{t-1}\)</span> is the trend for the previous period</li>
</ul>
<p>Just like with SES, Holt’s Linear Trend Method can incorporate a loss function to optimize the parameters. The loss function for Holt’s Linear Trend Method is the same as the loss function for SES, which is the Mean Squared Error (MSE).</p>
</section>
</section>
<section id="evaluation" class="level1">
<h1>Evaluation</h1>
<p>Now lets get into our code! For our examples, we’ll be using data from a cupcake shop, Christie’s Cupcakes. The dataset contains the weekly sales of the store from nearly the past 10 years (500 weeks).</p>
<p>Some additional info for our calculations:</p>
<p>The retail price per cupcake is $4, unit cost per cupcake is $0.80, and there is no salvage costs.</p>
<p>We’ll use the first 300 weeks as our basis for forecasting the next 200 weeks up to week 500.</p>
<section id="initial-setup" class="level2">
<h2 class="anchored" data-anchor-id="initial-setup">Initial Setup</h2>
<p>Let’s start by loading the data and taking a look at the first few rows and some basic analysis.</p>
<div id="6e5c3dbc" class="cell" data-execution_count="2">
<div class="cell-output cell-output-display" data-execution_count="2">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">t</th>
<th data-quarto-table-cell-role="th">demand</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>1</td>
<td>1974</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>2</td>
<td>1919</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>3</td>
<td>1731</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>4</td>
<td>1668</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>5</td>
<td>1895</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<div id="d53fd54e" class="cell" data-execution_count="3">
<div class="cell-output cell-output-display" data-execution_count="3">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">t</th>
<th data-quarto-table-cell-role="th">demand</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">count</td>
<td>500.000000</td>
<td>500.000000</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">mean</td>
<td>250.500000</td>
<td>3012.316000</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">std</td>
<td>144.481833</td>
<td>678.488964</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">min</td>
<td>1.000000</td>
<td>1606.000000</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">25%</td>
<td>125.750000</td>
<td>2477.000000</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">50%</td>
<td>250.500000</td>
<td>3045.000000</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">75%</td>
<td>375.250000</td>
<td>3528.250000</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">max</td>
<td>500.000000</td>
<td>4410.000000</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>We can see that the mean demand among the dataset is 3012 cupcakes with a standard deviation of 678. We’ve confirmed there are 500 data points in the dataset through the “counts” variable. We’ll take a look at the plot of the data.</p>
<div id="c668c0d7" class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>plt.plot(demand[<span class="st">'t'</span>], demand[<span class="st">'demand'</span>])</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'Weeks'</span>)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'Demand'</span>)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Demand vs Weeks'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="4">
<pre><code>Text(0.5, 1.0, 'Demand vs Weeks')</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="forecasting_files/figure-html/cell-5-output-2.png" width="602" height="449" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>There is a clear upward trend, with a decent amount of variation. That should give us a hint at which forecasting method to use. However, we will continue with all the methods to show the differences.</p>
</section>
<section id="average-1" class="level2">
<h2 class="anchored" data-anchor-id="average-1">Average</h2>
<p>As stated previously, averaging is the most common and simple method for forecasting. It could be moving average, or a cumulative average. Lets see what our average is for the first 300 weeks.</p>
<div id="118c64b6" class="cell" data-execution_count="5">
<div class="cell-output cell-output-stdout">
<pre><code>The average demand for cupcakes in the first 300 weeks is 2600.0 cupcakes</code></pre>
</div>
</div>
<p>With our average demand, lets determine how much profit we would make in the last 200 weeks.</p>
<div id="5d36d0a8" class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>retail <span class="op">=</span> <span class="dv">4</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>unit_cost <span class="op">=</span> <span class="fl">0.8</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>demand[<span class="st">'profit'</span>] <span class="op">=</span> np.where(demand[<span class="st">'demand'</span>] <span class="op">&gt;</span> avg_demand, retail<span class="op">*</span>avg_demand <span class="op">-</span> unit_cost<span class="op">*</span>avg_demand, retail<span class="op">*</span>demand[<span class="st">'demand'</span>] <span class="op">-</span> unit_cost<span class="op">*</span>avg_demand)</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>avg_profit <span class="op">=</span> np.<span class="bu">round</span>(demand.loc[<span class="dv">300</span>:, <span class="st">'profit'</span>].mean(), <span class="dv">2</span>)</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'The average profit for the last 200 weeks when using only the average demand for the past 300 weeks is $</span><span class="sc">{</span>avg_profit<span class="sc">}</span><span class="ss">'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>The average profit for the last 200 weeks when using only the average demand for the past 300 weeks is $8320.0</code></pre>
</div>
</div>
<div id="0c40fd7b" class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>profits <span class="op">=</span> pd.DataFrame({<span class="st">'Profit ($)'</span>:[avg_profit]}, index<span class="op">=</span>[<span class="st">'Avg'</span>])</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>profits</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="7">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">Profit ($)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">Avg</td>
<td>8320.0</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>Using just the mean as the way to forecast for the next 200 weeks makes an average weekly profit of $7508.40. Not bad, but lets see how the cumulative average works out.</p>
<section id="cumulative-average" class="level3">
<h3 class="anchored" data-anchor-id="cumulative-average">Cumulative Average</h3>
<p>Now, it doesn’t matter about the past 300 weeks, since we are calculating a new average after every week, but we’ll still only calculate the average weekly profit for the last 200 weeks for comparison.</p>
<div id="68031a30" class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>demand[<span class="st">'cum_avg_demand'</span>] <span class="op">=</span> demand[<span class="st">'demand'</span>].expanding().mean()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Let’s see what the cumulative average demand looks like when plotted.</p>
<div id="acd004c7" class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>plt.plot(demand[<span class="st">'t'</span>], demand[<span class="st">'cum_avg_demand'</span>])</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'Weeks'</span>)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'Cumulative Demand'</span>)</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Cumulative Demand vs Weeks'</span>)</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="forecasting_files/figure-html/cell-10-output-1.png" width="602" height="449" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>As expected, the cumulative average has much less variation as the weeks go on, and takes a very linear trend line.</p>
<div id="ced17e61" class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>demand[<span class="st">'cum_profit'</span>] <span class="op">=</span> np.where(demand[<span class="st">'demand'</span>] <span class="op">&gt;</span> demand[<span class="st">'cum_avg_demand'</span>], retail<span class="op">*</span>demand[<span class="st">'cum_avg_demand'</span>] <span class="op">-</span> unit_cost<span class="op">*</span>demand[<span class="st">'cum_avg_demand'</span>], retail<span class="op">*</span>demand[<span class="st">'demand'</span>] <span class="op">-</span> unit_cost<span class="op">*</span>demand[<span class="st">'cum_avg_demand'</span>])</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>avg_cum_profit <span class="op">=</span> np.<span class="bu">round</span>(demand.loc[<span class="dv">300</span>:, <span class="st">'cum_profit'</span>].mean(), <span class="dv">2</span>)</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'The average profit for the last 200 weeks when using the cumulative average demand is $</span><span class="sc">{</span>avg_cum_profit<span class="sc">}</span><span class="ss">'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>The average profit for the last 200 weeks when using the cumulative average demand is $8968.06</code></pre>
</div>
</div>
<div id="6509c48d" class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>profits.loc[<span class="st">'Avg Cumul.'</span>, <span class="st">'Profit ($)'</span>] <span class="op">=</span> avg_cum_profit</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>profits</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="11">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">Profit ($)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">Avg</td>
<td>8320.00</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">Avg Cumul.</td>
<td>8968.06</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>The average profit decreased for cumulative profit as compared to just using the average for the first 300 weeks.</p>
</section>
</section>
<section id="simple-exponential-smoothing-1" class="level2">
<h2 class="anchored" data-anchor-id="simple-exponential-smoothing-1">Simple Exponential Smoothing</h2>
<p>As discussed previously, Simple Exponential Smoothing (SES) assigns a weight to the current and previous level. If the weight (alpha) is high (closer to 1), that means the most recent data will weigh more heavily into the forecast than the past data points. On the opposite end, if alpha is low, it means the past data is used more to make the next forecast.</p>
<p>Let’s implement the SES method into our data. We’ll use a smoothing level of 0.2 initially and take a look at the plot.</p>
<div id="1f8f9c52" class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>SES_model <span class="op">=</span> SimpleExpSmoothing(demand.loc[:<span class="dv">300</span>, <span class="st">'demand'</span>]).fit(smoothing_level<span class="op">=</span><span class="fl">0.2</span>, optimized<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>demand[<span class="st">'SES_forecast'</span>] <span class="op">=</span> SES_model.fittedvalues</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>demand.loc[<span class="dv">300</span>:, <span class="st">'SES_forecast'</span>] <span class="op">=</span> SES_model.forecast(<span class="dv">200</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="03b8cf6e" class="cell" data-execution_count="13">
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="forecasting_files/figure-html/cell-14-output-1.png" width="602" height="449" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>The SES method produces a singular value for the last 200 weeks. This is correct, and is why SES method is not always used. As seen in the formula, it uses keeps using the last actual value to make the next predicition. Once we want to forecast, it produces a singular value for all the future forecasts until you want to recalculate.</p>
<p>Lets calculate the profit for SES non-optimized version.</p>
<div id="32bd8601" class="cell" data-execution_count="14">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>demand[<span class="st">'SES_profit'</span>] <span class="op">=</span> np.where(demand[<span class="st">'demand'</span>] <span class="op">&gt;</span> demand[<span class="st">'SES_forecast'</span>], retail<span class="op">*</span>demand[<span class="st">'SES_forecast'</span>] <span class="op">-</span> unit_cost<span class="op">*</span>demand[<span class="st">'SES_forecast'</span>], retail<span class="op">*</span>demand[<span class="st">'demand'</span>] <span class="op">-</span> unit_cost<span class="op">*</span>demand[<span class="st">'SES_forecast'</span>])</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>avg_SES_profit <span class="op">=</span> np.<span class="bu">round</span>(demand.loc[<span class="dv">300</span>:, <span class="st">'SES_profit'</span>].mean(), <span class="dv">2</span>)</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>profits.loc[<span class="st">'SES'</span>, <span class="st">'Profit ($)'</span>] <span class="op">=</span> avg_SES_profit</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>profits</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="14">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">Profit ($)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">Avg</td>
<td>8320.00</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">Avg Cumul.</td>
<td>8968.06</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">SES</td>
<td>10224.50</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>Implementing SES method increased profits by nearly $3000 weekly!</p>
<section id="ses-optimized" class="level3">
<h3 class="anchored" data-anchor-id="ses-optimized">SES Optimized</h3>
<p>Now we’ll use and optimized alpha with the SES method. Keep in mind, alpha is being optimized based on forecast, not on profit. We’ll see if the optimized alpha translates to increased profits.</p>
<div id="711fe441" class="cell" data-execution_count="15">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>SES_Opt_model <span class="op">=</span> SimpleExpSmoothing(demand.loc[:<span class="dv">300</span>, <span class="st">'demand'</span>]).fit(optimized<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>demand[<span class="st">'SES_Opt_forecast'</span>] <span class="op">=</span> SES_Opt_model.fittedvalues</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>demand.loc[<span class="dv">300</span>:, <span class="st">'SES_Opt_forecast'</span>] <span class="op">=</span> SES_Opt_model.forecast(<span class="dv">200</span>)</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>demand[<span class="st">'SES_Opt_profit'</span>] <span class="op">=</span> np.where(demand[<span class="st">'demand'</span>] <span class="op">&gt;</span> demand[<span class="st">'SES_Opt_forecast'</span>], retail<span class="op">*</span>demand[<span class="st">'SES_Opt_forecast'</span>] <span class="op">-</span> unit_cost<span class="op">*</span>demand[<span class="st">'SES_Opt_forecast'</span>], retail<span class="op">*</span>demand[<span class="st">'demand'</span>] <span class="op">-</span> unit_cost<span class="op">*</span>demand[<span class="st">'SES_Opt_forecast'</span>])</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>avg_SES_Opt_profit <span class="op">=</span> np.<span class="bu">round</span>(demand.loc[<span class="dv">300</span>:, <span class="st">'SES_Opt_profit'</span>].mean(), <span class="dv">2</span>)</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>profits.loc[<span class="st">'SES Optim.'</span>, <span class="st">'Profit ($)'</span>] <span class="op">=</span> avg_SES_Opt_profit</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>profits</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="15">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">Profit ($)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">Avg</td>
<td>8320.00</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">Avg Cumul.</td>
<td>8968.06</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">SES</td>
<td>10224.50</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">SES Optim.</td>
<td>10249.05</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>The optimized version did increase profits by about $25 weekly!</p>
<p>Another method to ensure you have enough inventory to meet your demand is implementing a safety stock. A saftey stock allows you to be ready for the fluctuations in your demand. It is calculated by determing your cost of understocking and overstocking. Once you have those metrics, you determine your target service level, which the percentile of safety stock you want to keep on hand based on your error in your forecast to the actual demand. The Cost of understocking and overstocking are:</p>
<p><span class="math display">\[ Cu = retailprice - unitcost \]</span> <span class="math display">\[ Cu = unitcost - salvagevalue \]</span></p>
<p>The formula for Target Service Level is:</p>
<p><span class="math display">\[ TSL = Cu/(Cu-Co) \]</span></p>
<p>Let’s find the profit for our optimized SES model when incorporating a safety stock. First we’ll find the Target service level.</p>
<div id="09dc84cb" class="cell" data-execution_count="16">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>Cu <span class="op">=</span> retail <span class="op">-</span> unit_cost</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>Co <span class="op">=</span> unit_cost</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>TSL <span class="op">=</span> Cu<span class="op">/</span>(Cu<span class="op">-</span>Co)</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>TSL</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="16">
<pre><code>1.3333333333333333</code></pre>
</div>
</div>
<p>Our TSL for this product is 0.8, or 80% service level. We’ll use that to find our safety stock.</p>
<div id="c8731bed" class="cell" data-execution_count="17">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> cumulative_quantile(x):</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x.expanding().quantile(<span class="fl">0.8</span>)</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>demand[<span class="st">'error_op'</span>] <span class="op">=</span> demand[<span class="st">'demand'</span>] <span class="op">-</span> demand[<span class="st">'SES_Opt_forecast'</span>]</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>demand[<span class="st">'cum_error_optim'</span>] <span class="op">=</span> demand[<span class="st">'error_op'</span>].transform(cumulative_quantile)</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>demand[<span class="st">'stockQ_op'</span>] <span class="op">=</span> demand[<span class="st">'SES_Opt_forecast'</span>] <span class="op">+</span> demand[<span class="st">'cum_error_optim'</span>]</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>demand[<span class="st">'profit_op'</span>] <span class="op">=</span> np.where(demand[<span class="st">'demand'</span>] <span class="op">&gt;</span> demand[<span class="st">'stockQ_op'</span>], retail<span class="op">*</span>demand[<span class="st">'stockQ_op'</span>] <span class="op">-</span> unit_cost<span class="op">*</span>demand[<span class="st">'stockQ_op'</span>], retail<span class="op">*</span>demand[<span class="st">'demand'</span>] <span class="op">-</span> unit_cost<span class="op">*</span>demand[<span class="st">'stockQ_op'</span>])</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>avg_SES_Opt_safety_profit <span class="op">=</span> np.<span class="bu">round</span>(demand.loc[<span class="dv">300</span>:, <span class="st">'profit_op'</span>].mean(), <span class="dv">2</span>)</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>profits.loc[<span class="st">'SES Optim. Safety'</span>, <span class="st">'Profit ($)'</span>] <span class="op">=</span> avg_SES_Opt_safety_profit</span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>profits</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="17">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">Profit ($)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">Avg</td>
<td>8320.00</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">Avg Cumul.</td>
<td>8968.06</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">SES</td>
<td>10224.50</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">SES Optim.</td>
<td>10249.05</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">SES Optim. Safety</td>
<td>11039.99</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>Profits increased by over $350 weekly!</p>
<p>As discussed previously, the optimization is happening based on the forecasts, and not profits. Let’s see if we can find a better alpha which translates to higher profits.</p>
<div id="2465ac48" class="cell" data-execution_count="18">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>SES_opt_alpha <span class="op">=</span> SES_Opt_model.params[<span class="st">'smoothing_level'</span>]</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>SES_opt_alpha</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="18">
<pre><code>0.08742752183220932</code></pre>
</div>
</div>
<div id="e4fa1132" class="cell" data-execution_count="19">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>alpha_list <span class="op">=</span> []</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>SES_profit_list <span class="op">=</span> []</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> alpha <span class="kw">in</span> np.arange(<span class="dv">0</span>,<span class="dv">1</span>,<span class="fl">0.01</span>):</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>    SES_Opt_model <span class="op">=</span> SimpleExpSmoothing(demand.loc[:<span class="dv">300</span>, <span class="st">'demand'</span>]).fit(smoothing_level <span class="op">=</span> alpha, optimized<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>    demand[<span class="st">'SES_Opt_forecast'</span>] <span class="op">=</span> SES_Opt_model.fittedvalues</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>    demand.loc[<span class="dv">300</span>:, <span class="st">'SES_Opt_forecast'</span>] <span class="op">=</span> SES_Opt_model.forecast(<span class="dv">200</span>)</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>    demand[<span class="st">'SES_Opt_profit'</span>] <span class="op">=</span> np.where(demand[<span class="st">'demand'</span>] <span class="op">&gt;</span> demand[<span class="st">'SES_Opt_forecast'</span>], retail<span class="op">*</span>demand[<span class="st">'SES_Opt_forecast'</span>] <span class="op">-</span> unit_cost<span class="op">*</span>demand[<span class="st">'SES_Opt_forecast'</span>], retail<span class="op">*</span>demand[<span class="st">'demand'</span>] <span class="op">-</span> unit_cost<span class="op">*</span>demand[<span class="st">'SES_Opt_forecast'</span>])</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>    avg_SES_Opt_profit <span class="op">=</span> np.<span class="bu">round</span>(demand.loc[<span class="dv">300</span>:, <span class="st">'SES_Opt_profit'</span>].mean(), <span class="dv">2</span>)</span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>    alpha_list.append(alpha)</span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>    SES_profit_list.append(avg_SES_Opt_profit)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="a2aed20f" class="cell" data-execution_count="20">
<div class="cell-output cell-output-stdout">
<pre><code> The maximum profit capable through SES method is $10260.53 which resulted from an alpha value of 0.12.</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="20">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">Profit ($)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">Avg</td>
<td>8320.00</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">Avg Cumul.</td>
<td>8968.06</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">SES</td>
<td>10224.50</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">SES Optim.</td>
<td>10249.05</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">SES Optim. Safety</td>
<td>11039.99</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">SES Best Profit</td>
<td>10260.53</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>The previous optimized model was fairly close with an alpha of 0.08 when compared to the alpha which produces the best profit for the next 200 weeks. This is not always the case where the optimized alpha is close to the alpha which produces the best profit. The optimzied model based on profit was less than when we incorporated safety stock, but still more than using the optimized parameters based on forecast.</p>
<p>This also depends on your strategy, whether its profit or hedging because you don’t want to potentially overstock.</p>
</section>
</section>
<section id="holts-linear-trend-method-1" class="level2">
<h2 class="anchored" data-anchor-id="holts-linear-trend-method-1">Holt’s Linear Trend Method</h2>
<p>Now that we’ve seen the SES method in work, it’s time for Holt’s Linear Trend Method. As the name says, Holt’s adds on to SES by introducing a trend in addition to the level.</p>
<p>We can clearly see a trend in the demand, so forecasts and this profits should increase.</p>
<p>Before we use Holt’s, we’ll first run a linear regression model to get an initial level and trend for our model by using the intercept and coefficient. This method can lead to better forecasting by having relatively accurate starting point.</p>
<div id="1c96cb78" class="cell" data-execution_count="21">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>lr_model <span class="op">=</span> LinearRegression().fit(demand.loc[:<span class="dv">300</span>, <span class="st">'t'</span>].values.reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>), demand.loc[:<span class="dv">300</span>,<span class="st">'demand'</span>].values)</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>init_trend <span class="op">=</span> lr_model.coef_[<span class="dv">0</span>] </span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>init_level <span class="op">=</span> lr_model.intercept_</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>init_level, init_trend</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="21">
<pre><code>(1923.0031229235879, 4.483137004686365)</code></pre>
</div>
</div>
<p>Now that we have our initial trend and level, we’ll implement those in Holt’s model. We’ll use 0.2 for alpha and beta for our initial calculations. We will plot the data as well to see how the forecasted demand follows the actual demand.</p>
<div id="8adf73b0" class="cell" data-execution_count="22">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>Holt_model <span class="op">=</span> Holt(demand.loc[:<span class="dv">300</span>,<span class="st">'demand'</span>], initialization_method<span class="op">=</span><span class="st">"known"</span>, initial_level<span class="op">=</span>init_level, initial_trend<span class="op">=</span>init_trend).fit(smoothing_level<span class="op">=</span><span class="fl">0.2</span>, smoothing_trend<span class="op">=</span><span class="fl">0.2</span>, optimized<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>demand[<span class="st">'forecast_holt'</span>] <span class="op">=</span> Holt_model.fittedvalues</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>demand.loc[<span class="dv">300</span>:, <span class="st">'forecast_holt'</span>] <span class="op">=</span> Holt_model.forecast(<span class="dv">200</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="97aafd3b" class="cell" data-execution_count="23">
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="forecasting_files/figure-html/cell-24-output-1.png" width="602" height="449" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>The forecasted results are way off! The forecasts are decreasing rather than increasing. This is likely due to alpha and beta values combined with the large amount of variation in the data.</p>
<p>A lower smoothing level means it has less weight in the most recent data and more weight in the past data. Same goes for a low smoothing trend. A low smoothing trend would mean it is less volatile to short term fluctuations, which there is plenty in this data. Maybe the alpha and beta values are too large, even though they’re at the lower end of the range?</p>
<p>Let’s see what the optimized model comes up with.</p>
<section id="optimized-holts" class="level3">
<h3 class="anchored" data-anchor-id="optimized-holts">Optimized Holts</h3>
<div id="b6aa27a1" class="cell" data-execution_count="24">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>Holt_opt_model <span class="op">=</span> Holt(demand.loc[:<span class="dv">300</span>,<span class="st">'demand'</span>], initialization_method<span class="op">=</span><span class="st">"known"</span>, initial_level<span class="op">=</span>init_level, initial_trend<span class="op">=</span>init_trend).fit(optimized<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>demand[<span class="st">'forecast_holt_opt'</span>] <span class="op">=</span> Holt_opt_model.fittedvalues</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>demand.loc[<span class="dv">300</span>:, <span class="st">'forecast_holt_opt'</span>] <span class="op">=</span> Holt_opt_model.forecast(<span class="dv">200</span>)</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>optimal_alpha <span class="op">=</span> Holt_opt_model.model.params[<span class="st">'smoothing_level'</span>]</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>optimal_beta <span class="op">=</span> Holt_opt_model.model.params[<span class="st">'smoothing_trend'</span>]</span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>optimal_alpha, optimal_beta</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="24">
<pre><code>(1.4901161193847656e-08, 0.0)</code></pre>
</div>
</div>
<p>The optimized holt parameters are even lower than 0.2! Alpha and beta are both close to 0, meaning that forecastingrelies on the long term trend and levels, and should not be misguided by short term fluctuations.</p>
<p>Here’s a plot of the optimized data.</p>
<div id="56ed6e3c" class="cell" data-execution_count="25">
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="forecasting_files/figure-html/cell-26-output-1.png" width="602" height="449" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>The fitted values we used to train our optimized holt value have almost no fluctuation. It is nearly a perfect linear line, which it should be with a beta of 0.</p>
<p>Now lets check our profits for both.</p>
<div id="7ad990aa" class="cell" data-execution_count="26">
<div class="cell-output cell-output-display" data-execution_count="26">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">Profit ($)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">Avg</td>
<td>8320.00</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">Avg Cumul.</td>
<td>8968.06</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">SES</td>
<td>10224.50</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">SES Optim.</td>
<td>10249.05</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">SES Optim. Safety</td>
<td>11039.99</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">SES Best Profit</td>
<td>10260.53</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">Holt</td>
<td>8627.90</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">Holt Optim.</td>
<td>11241.21</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>Profits are still better than just using the average or the cumulative average when alpha and beta are 0.2, but less than all profits with SES.</p>
<p>However, our optimized Holt model did significantly better than any of the other models!</p>
<p>Before optimizing on profit rather than forecast, lets see what implementing a safety stock does for Holts.</p>
<div id="5e2c186a" class="cell" data-execution_count="27">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>demand[<span class="st">'error_op'</span>] <span class="op">=</span> demand[<span class="st">'demand'</span>] <span class="op">-</span> demand[<span class="st">'forecast_holt_opt'</span>]</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>demand[<span class="st">'cum_error_optim'</span>] <span class="op">=</span> demand[<span class="st">'error_op'</span>].transform(cumulative_quantile)</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>demand[<span class="st">'stockQ_op'</span>] <span class="op">=</span> demand[<span class="st">'forecast_holt_opt'</span>] <span class="op">+</span> demand[<span class="st">'cum_error_optim'</span>]</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>demand[<span class="st">'profit_op'</span>] <span class="op">=</span> np.where(demand[<span class="st">'demand'</span>] <span class="op">&gt;</span> demand[<span class="st">'stockQ_op'</span>], retail<span class="op">*</span>demand[<span class="st">'stockQ_op'</span>] <span class="op">-</span> unit_cost<span class="op">*</span>demand[<span class="st">'stockQ_op'</span>], retail<span class="op">*</span>demand[<span class="st">'demand'</span>] <span class="op">-</span> unit_cost<span class="op">*</span>demand[<span class="st">'stockQ_op'</span>])</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>avg_Holt_Opt_safety_profit <span class="op">=</span> np.<span class="bu">round</span>(demand.loc[<span class="dv">300</span>:, <span class="st">'profit_op'</span>].mean(), <span class="dv">2</span>)</span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>profits.loc[<span class="st">'Holt Optim. Safety'</span>, <span class="st">'Profit ($)'</span>] <span class="op">=</span> avg_Holt_Opt_safety_profit</span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a>profits</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="27">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">Profit ($)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">Avg</td>
<td>8320.00</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">Avg Cumul.</td>
<td>8968.06</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">SES</td>
<td>10224.50</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">SES Optim.</td>
<td>10249.05</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">SES Optim. Safety</td>
<td>11039.99</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">SES Best Profit</td>
<td>10260.53</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">Holt</td>
<td>8627.90</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">Holt Optim.</td>
<td>11241.21</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">Holt Optim. Safety</td>
<td>11318.08</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>Profit’s increased by about $80 a week!</p>
<p>Now lets see if we can find the best parameters with Holt’s model for optimizing profit.</p>
<div id="10ad1414" class="cell" data-execution_count="28">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>alpha_list <span class="op">=</span> []</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>beta_list <span class="op">=</span> []</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>Holt_profit_list <span class="op">=</span> []</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> alpha <span class="kw">in</span> np.arange(<span class="dv">0</span>,<span class="dv">1</span>,<span class="fl">0.01</span>):</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> beta <span class="kw">in</span> np.arange(<span class="dv">0</span>,<span class="dv">1</span>,<span class="fl">0.01</span>):</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>        Holt_profit_model <span class="op">=</span> Holt(demand.loc[:<span class="dv">300</span>, <span class="st">'demand'</span>], initialization_method<span class="op">=</span><span class="st">"known"</span>, initial_level<span class="op">=</span>init_level, initial_trend<span class="op">=</span>init_trend).fit(smoothing_level <span class="op">=</span> alpha, smoothing_trend <span class="op">=</span> beta, optimized<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>        demand[<span class="st">'Holt_demand'</span>] <span class="op">=</span> Holt_profit_model.fittedvalues</span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>        demand.loc[<span class="dv">300</span>:, <span class="st">'Holt_demand'</span>] <span class="op">=</span> Holt_profit_model.forecast(<span class="dv">200</span>)</span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a>        demand[<span class="st">'Holt_Opt_profit'</span>] <span class="op">=</span> np.where(demand[<span class="st">'demand'</span>] <span class="op">&gt;</span> demand[<span class="st">'Holt_demand'</span>], retail<span class="op">*</span>demand[<span class="st">'Holt_demand'</span>] <span class="op">-</span> unit_cost<span class="op">*</span>demand[<span class="st">'Holt_demand'</span>], retail<span class="op">*</span>demand[<span class="st">'demand'</span>] <span class="op">-</span> unit_cost<span class="op">*</span>demand[<span class="st">'Holt_demand'</span>])</span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a>        avg_Holt_profit <span class="op">=</span> np.<span class="bu">round</span>(demand.loc[<span class="dv">300</span>:, <span class="st">'Holt_Opt_profit'</span>].mean(), <span class="dv">2</span>)</span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a>        alpha_list.append(alpha)</span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a>        beta_list.append(beta)</span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a>        Holt_profit_list.append(avg_Holt_profit)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="57dc20fe" class="cell" data-execution_count="29">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'The optimal parameters in regards to profit were an alpha of </span><span class="sc">{</span>alpha_list[np.argmax(Holt_profit_list)]<span class="sc">}</span><span class="ss"> and a beta of </span><span class="sc">{</span>np<span class="sc">.</span><span class="bu">round</span>(beta_list[np.argmax(Holt_profit_list)], <span class="dv">2</span>)<span class="sc">}</span><span class="ss">. This produced an average weekly profit of $</span><span class="sc">{</span>np<span class="sc">.</span><span class="bu">max</span>(Holt_profit_list)<span class="sc">}</span><span class="ss">.'</span>)</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>profits.loc[<span class="st">'Holt Best Profit'</span>, <span class="st">'Profit ($)'</span>] <span class="op">=</span> np.<span class="bu">max</span>(Holt_profit_list)</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>profits</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>The optimal parameters in regards to profit were an alpha of 0.07 and a beta of 0.95. This produced an average weekly profit of $11332.89.</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="29">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">Profit ($)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">Avg</td>
<td>8320.00</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">Avg Cumul.</td>
<td>8968.06</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">SES</td>
<td>10224.50</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">SES Optim.</td>
<td>10249.05</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">SES Optim. Safety</td>
<td>11039.99</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">SES Best Profit</td>
<td>10260.53</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">Holt</td>
<td>8627.90</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">Holt Optim.</td>
<td>11241.21</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">Holt Optim. Safety</td>
<td>11318.08</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">Holt Best Profit</td>
<td>11332.89</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>In contradiction, the optimal parameters in regards to profit had a higher alpha, but still low, meaning it using past data created better results than current data in regards to smoothing level. However, the smoothing trend was very high (close to 1), meaning it was best to follow the most recent changes in trend than historical trend.</p>
<p>Let’s take a look at the plot to confirm.</p>
<div id="67aeecdc" class="cell" data-execution_count="30">
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="forecasting_files/figure-html/cell-31-output-1.png" width="602" height="449" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>The forecasted trend was still positive, but had a slightly higher slope than the optimized model. This caused the forecasts to be at the higher end of the actual demand in most weeks. Since the cost of understocking is much higher than overstocking, that was the difference in having the best possible profit using holt’s linear trend method.</p>
</section>
</section>
</section>
<section id="conclusion" class="level1">
<h1>Conclusion</h1>
<p>We went over multiple methods to forecast demand, with the main emphasis on Simple Exponential Smoothing and Holt’s Linear Trend Method. SES does not account for trend, but does give weights to past values in order to determine how much the model should be using most recent and past values in its forecasting.</p>
<p>Holt’s method takes it a step further, incorporating a trend component into the equation, which allows the model to either increase, decrease, or stay the same depending on the parameters in your model and the data itself.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    const typesetMath = (el) => {
      if (window.MathJax) {
        // MathJax Typeset
        window.MathJax.typeset([el]);
      } else if (window.katex) {
        // KaTeX Render
        var mathElements = el.getElementsByClassName("math");
        var macros = [];
        for (var i = 0; i < mathElements.length; i++) {
          var texText = mathElements[i].firstChild;
          if (mathElements[i].tagName == "SPAN") {
            window.katex.render(texText.data, mathElements[i], {
              displayMode: mathElements[i].classList.contains('display'),
              throwOnError: false,
              macros: macros,
              fleqn: false
            });
          }
        }
      }
    }
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        typesetMath(container);
        return container.innerHTML
      } else {
        typesetMath(note);
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      typesetMath(note);
      return note.innerHTML;
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>